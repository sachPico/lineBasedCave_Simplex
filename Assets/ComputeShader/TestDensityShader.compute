#pragma kernel CSMain
#include "/Include/Inputs.compute"
#include "/Include/SimplexNoise.compute"

struct LineProperties
{
    int nodeA, nodeB;
    float3 xLocal, yLocal;
    float AC, BD, CE, DF, lineLength;
};

struct NodeProperties
{
    float3 position;
    float minRadius, maxRadius;
};

bool isWorldSpaceNoise;
int totalVertexLayer, totalVertex, index;
float1 smoothingFactor;
float1 noiseWeight;
float1 octaveMaxValue;
float3 offset;
float3 noiseOffset;
float1 noiseScale;
float frequency, amplitude, lacunarity, persistence;

StructuredBuffer<float3> octaveOffset;
RWStructuredBuffer<NodeProperties> nodeProps;
RWStructuredBuffer<LineProperties> lineProps;

bool IsInRadius(NodeProperties n, float1 r, float3 sp)
{
    float1 dist = length(sp - n.position);
    if(dist <= r) return true;
    else return false;
}

bool IsOutRadius(NodeProperties n, float1 r, float3 sp)
{
    float1 dist = length(sp - n.position);
    if(dist >= r) return true;
    else return false;
}

float1 Falloff(float1 dist, float1 minR, float1 maxR)
{
    float1 fV = (maxR-dist)/(maxR-minR);
    if(fV<isoLevel) return 0;
    else return clamp(fV,0,1);
}

float1 EndToEndDensity(NodeProperties np, int spID)
{
    if(length(samplePoints[spID]-np.position) < np.maxRadius)
    {
        return Falloff(length(samplePoints[spID]-np.position), 0, np.maxRadius);
    }
    else
    {
        return 0;
    }
}

int GetClosestLineID(float4 sp)
{
    LineProperties lp;
    NodeProperties nA, nB;
    float1 interpolatedRadius, orthogonalProjection, sampleToLine, closestDist;
    float3 nodeAToSample, nodeBToSample;
    int closestLineIndex=-1;

    closestDist = 2147483647;

    for(uint i=0; i<lineProps.Length; i++)
    {
        lp = lineProps[i];
        nA = nodeProps[lp.nodeA];
        nB = nodeProps[lp.nodeB];

        if(nodeProps[lp.nodeA].maxRadius < nodeProps[lp.nodeB].maxRadius)
        {
            nA=nodeProps[lp.nodeA];
            nB=nodeProps[lp.nodeB];
        }
        else
        {
            nA=nodeProps[lp.nodeB];
            nB=nodeProps[lp.nodeA];
        }

        nodeAToSample = sp.xyz - nA.position;
        nodeBToSample = sp.xyz - nB.position;
        orthogonalProjection = dot(nodeAToSample, normalize(nB.position-nA.position));
        sampleToLine = sqrt(pow(length(nodeAToSample),2)-pow(orthogonalProjection,2));
        interpolatedRadius = (orthogonalProjection+lp.AC)/(lp.lineLength+lp.AC-lp.BD)*(lp.DF-lp.CE)+lp.CE;

        if(sp.w!=-1 && sampleToLine <= interpolatedRadius && orthogonalProjection>=-lp.AC && orthogonalProjection<=lp.lineLength-lp.BD)
        {
            closestDist = sampleToLine;
            closestLineIndex=i;
        }
    }
    return closestLineIndex;
    
}

float1 SetDensity(int index)
{
    NodeProperties closestNodeA, closestNodeB;
    LineProperties closestLineProps;
    float1 lineLength, orthogonalProjectionToClosestLine, falloffValue, densityValue, noiseValue=0, interpolatedMaxRadius, interpolatedMinRadius, dist, weight;
    float3 orthoProject, normalizedLine, noiseInput;
    
    int id = GetClosestLineID(samplePoints[index]);
    if(id==-1)
    {
        return 0;
    }
    closestLineProps = lineProps[id];
    if(nodeProps[lineProps[id].nodeA].maxRadius < nodeProps[lineProps[id].nodeB].maxRadius)
    {
        closestNodeA = nodeProps[closestLineProps.nodeA];
        closestNodeB = nodeProps[closestLineProps.nodeB];
    }
    else
    {
        closestNodeA = nodeProps[closestLineProps.nodeB];
        closestNodeB = nodeProps[closestLineProps.nodeA];
    }

    normalizedLine = normalize(closestNodeB.position-closestNodeA.position);
    orthogonalProjectionToClosestLine = dot(samplePoints[index].xyz-closestNodeA.position, normalizedLine);

    orthoProject = closestNodeA.position+(orthogonalProjectionToClosestLine * normalizedLine);
    dist = sqrt(pow(length(samplePoints[index].xyz-closestNodeA.position),2) - pow(orthogonalProjectionToClosestLine,2));//length(orthoProject - samplePoints[index].xyz);

    interpolatedMaxRadius = closestLineProps.CE + ((orthogonalProjectionToClosestLine+closestLineProps.AC)/(closestLineProps.lineLength+closestLineProps.AC-closestLineProps.BD) * (closestLineProps.DF - closestLineProps.CE));
        
    if(dist <= interpolatedMaxRadius)
    {
        //falloffValue = Falloff(dist, 0, interpolatedMaxRadius);
        //densityValue = isoLevel;//isoLevel;
        densityValue = clamp(Falloff(dist, 0, interpolatedMaxRadius), isoLevel, 1);
    }
    else
    {
        return 0;
    }
    if(isWorldSpaceNoise)
    {
        noiseInput = samplePoints[index].xyz;
    }
    else
    {
        noiseInput.z = orthogonalProjectionToClosestLine / noiseScale;
        noiseInput.x = dot(samplePoints[index].xyz-closestNodeA.position, closestLineProps.xLocal) / noiseScale;
        noiseInput.y = dot(samplePoints[index].xyz-closestNodeA.position, closestLineProps.yLocal) / noiseScale;
    }
    frequency = 1;
    amplitude = 1;
    weight = 1;
    for(int i=0; i<octaveOffset.Length; i++)
    {
        noiseInput = noiseInput/frequency;//+octaveOffset[i]+noiseOffset;//*frequency;
        noiseValue += noise3D(noiseInput.x, noiseInput.y, noiseInput.z) * amplitude;
        octaveMaxValue += amplitude;
        //float v = 1-abs(noise3D(noiseInput.x, noiseInput.y, noiseInput.z));
        //v *= v*weight;
        //noiseValue += v*amplitude;
        //weight = max(min(v*noiseWeight,1),0);
        frequency *= lacunarity;
        amplitude *= persistence;
    }
    noiseValue /= octaveMaxValue;//octaveOffset.Length;
    densityValue += (1-isoLevel) * noiseValue;
    if(densityValue+noiseValue > 1)
    {
        densityValue = isoLevel;
        //densityValue %= isoLevel;//isoLevel + ((densityValue+noiseValue-1)/(1-isoLevel));
    }
    else
    {
        densityValue += noiseValue;
    }
    return densityValue;
}

void SetPosition(int3 coord)
{
    samplePoints[index].x = coord.x * voxelSize + offset.x;
    samplePoints[index].y = coord.y * voxelSize + offset.y;
    samplePoints[index].z = coord.z * voxelSize + offset.z;
}

[numthreads(1,1,1)]
void CSMain (uint3 threadID : SV_DISPATCHTHREADID)
{
    if(threadID.x>numVertexX || threadID.y>numVertexY || threadID.z>numVertexZ)
    {
        return;
    }
    totalVertexLayer = numVertexX*numVertexZ;

    index = GetIDFromCoord(threadID);
    SetPosition(threadID);
    samplePoints[index].w = SetDensity(index);
}
