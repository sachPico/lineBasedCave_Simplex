#pragma kernel CSMain
#include "/Include/Inputs.compute"
#include "/Include/SimplexNoise.compute"

struct LineProperties
{
    int nodeA, nodeB;
    float3 xLocal, yLocal;
    float AC, BD, CE, DF, lineLength;
};

struct NodeProperties
{
    float3 position;
    float minRadius, maxRadius;
};

bool isWorldSpaceNoise;
int totalVertexLayer, totalVertex, index;
float1 smoothingFactor;
float1 noiseWeight;
float1 weight;
float1 octaveMaxValue;
float3 offset;
float3 noiseOffset;
float1 noiseScale;
float frequency, amplitude, lacunarity, persistence;

StructuredBuffer<float3> octaveOffset;
RWStructuredBuffer<NodeProperties> nodeProps;
RWStructuredBuffer<LineProperties> lineProps;

bool IsInRadius(NodeProperties n, float1 r, float3 sp)
{
    float1 dist = length(sp - n.position);
    if(dist <= r) return true;
    else return false;
}

bool IsOutRadius(NodeProperties n, float1 r, float3 sp)
{
    float1 dist = length(sp - n.position);
    if(dist >= r) return true;
    else return false;
}

float1 Falloff(float1 dist, float1 minR, float1 maxR)
{
    float1 fV = (maxR-dist)/(maxR-minR);
    if(fV<isoLevel) return 0;
    else return clamp(fV,0,1);
}

float1 simplexNoise(int dimension, float3 inputCoordinate)
{
    float1 v=0;
    frequency = 1;
    amplitude = 1;
    octaveMaxValue = 0;
    weight = 1;
    if(dimension == 2)
    {
        for(int i=0; i<octaveOffset.Length; i++)
        {
            v += noise2D(inputCoordinate.x+octaveOffset[i].x, inputCoordinate.y+octaveOffset[i].y) * amplitude;
            octaveMaxValue += amplitude;
            frequency *= lacunarity;
            amplitude *= persistence;
        }
    }
    if(dimension == 3)
    {
        for(int i=0; i<octaveOffset.Length; i++)
        {
            v += noise3D(inputCoordinate.x+octaveOffset[i].x, inputCoordinate.y+octaveOffset[i].y, inputCoordinate.z+octaveOffset[i].z) * amplitude;
            octaveMaxValue += amplitude;
            frequency *= lacunarity;
            amplitude *= persistence;
        }
    }
    v /= octaveMaxValue;
    return v;
}

float1 EndToEndDensity(NodeProperties np, int spID)
{
    if(length(samplePoints[spID]-np.position) < np.maxRadius)
    {
        return Falloff(length(samplePoints[spID]-np.position), 0, np.maxRadius);
    }
    else
    {
        return 0;
    }
}

int GetClosestLineID(float4 sp)
{
    LineProperties lp;
    NodeProperties nA, nB;
    float1 interpolatedRadius, orthogonalProjection, sampleToLine, closestDist;
    float3 nodeAToSample, nodeBToSample;
    int closestLineIndex=-1;

    closestDist = 2147483647;

    for(uint i=0; i<lineProps.Length; i++)
    {
        lp = lineProps[i];
        nA = nodeProps[lp.nodeA];
        nB = nodeProps[lp.nodeB];

        if(nodeProps[lp.nodeA].maxRadius < nodeProps[lp.nodeB].maxRadius)
        {
            nA=nodeProps[lp.nodeA];
            nB=nodeProps[lp.nodeB];
        }
        else
        {
            nA=nodeProps[lp.nodeB];
            nB=nodeProps[lp.nodeA];
        }

        nodeAToSample = sp.xyz - nA.position;
        nodeBToSample = sp.xyz - nB.position;
        orthogonalProjection = dot(nodeAToSample, normalize(nB.position-nA.position));
        sampleToLine = sqrt(pow(length(nodeAToSample),2)-pow(orthogonalProjection,2));
        interpolatedRadius = (orthogonalProjection+lp.AC)/(lp.lineLength+lp.AC-lp.BD)*(lp.DF-lp.CE)+lp.CE;

        if(sp.w!=-1 && sampleToLine <= interpolatedRadius && orthogonalProjection>=-lp.AC && orthogonalProjection<=lp.lineLength-lp.BD)
        {
            closestDist = sampleToLine;
            closestLineIndex=i;
        }
    }
    return closestLineIndex;
    
}

float1 SetDensity(int index)
{
    NodeProperties closestNodeA, closestNodeB;
    LineProperties closestLineProps;
    float1 lineLength, orthogonalProjectionToClosestLine, falloffValue, densityValue=0, noiseValue=0, interpolatedMaxRadius, interpolatedMinRadius, dist;
    float3 orthoProject, normalizedLine, noiseInput;
    float3 a, b;
    
    int id = GetClosestLineID(samplePoints[index]);
    if(id==-1)
    {
        return 0;
    }
    closestLineProps = lineProps[id];
    if(nodeProps[lineProps[id].nodeA].maxRadius < nodeProps[lineProps[id].nodeB].maxRadius)
    {
        closestNodeA = nodeProps[closestLineProps.nodeA];
        closestNodeB = nodeProps[closestLineProps.nodeB];
    }
    else
    {
        closestNodeA = nodeProps[closestLineProps.nodeB];
        closestNodeB = nodeProps[closestLineProps.nodeA];
    }

    normalizedLine = normalize(closestNodeB.position-closestNodeA.position);
    orthogonalProjectionToClosestLine = dot(samplePoints[index].xyz-closestNodeA.position, normalizedLine);

    orthoProject = closestNodeA.position+(orthogonalProjectionToClosestLine * normalizedLine);
    dist = length(samplePoints[index].xyz - orthoProject);//sqrt(pow(length(samplePoints[index].xyz-closestNodeA.position),2) - pow(orthogonalProjectionToClosestLine,2));//length(orthoProject - samplePoints[index].xyz);

    interpolatedMaxRadius = closestLineProps.CE + ((orthogonalProjectionToClosestLine+closestLineProps.AC)/(closestLineProps.lineLength+closestLineProps.AC-closestLineProps.BD) * (closestLineProps.DF - closestLineProps.CE));
        
    /*if(dist <= interpolatedMaxRadius)
    {
        //falloffValue = Falloff(dist, 0, interpolatedMaxRadius);
        //densityValue = isoLevel;//isoLevel;
        densityValue = clamp(Falloff(dist, 0, interpolatedMaxRadius), isoLevel, 1);
    }
    else
    {
        return 0;
    }
    if(isWorldSpaceNoise)
    {
        noiseInput = samplePoints[index].xyz;
    }
    else
    {
        noiseInput.z = orthogonalProjectionToClosestLine / noiseScale;
        noiseInput.x = dot(samplePoints[index].xyz-closestNodeA.position, closestLineProps.xLocal) / noiseScale;
        noiseInput.y = dot(samplePoints[index].xyz-closestNodeA.position, closestLineProps.yLocal) / noiseScale;
    }*/
    

    if(dist==0)
    {
        return isoLevel;
    }
    else
    {
        float angle, yLocal;
        a = samplePoints[index].xyz - orthoProject;
        b = closestLineProps.xLocal;// + orthoProject;
        yLocal = dot(a,closestLineProps.yLocal);
        angle = degrees((acos(dot(a, b)/(length(a)*length(b)))));
        if(yLocal<0)
        {
            angle = 360 - angle;
        }
        //angle %= 360;

        noiseInput.x = angle / 360 * noiseScale;//(acos()%360)/360;
        noiseInput.y = orthogonalProjectionToClosestLine/closestLineProps.lineLength * noiseScale;
        noiseInput.z = 0;
        //noiseInput += noiseOffset;

        noiseValue = simplexNoise(2, noiseInput);
        //octaveOffset.Length;
        if(dist <= interpolatedMaxRadius - (noiseValue*interpolatedMaxRadius/2))
        {
            
            densityValue = isoLevel;
        }
        else
        {
            //noiseInput.z += dist;//orthogonalProjectionToClosestLine;
            //noiseInput.x = dot(samplePoints[index].xyz-closestNodeA.position, closestLineProps.xLocal) * noiseScale;
            //noiseInput.y = dot(samplePoints[index].xyz-closestNodeA.position, closestLineProps.yLocal) * noiseScale;
            /*noiseInput.z = orthogonalProjectionToClosestLine;
            noiseInput.x = dot(samplePoints[index].xyz-closestNodeA.position, closestLineProps.xLocal) * noiseScale;
            noiseInput.y = dot(samplePoints[index].xyz-closestNodeA.position, closestLineProps.yLocal) * noiseScale;
            densityValue = simplexNoise(3, noiseInput) * 2;*/
            densityValue = 0;//simplexNoise(3, noiseInput);
        }
    }
    /*densityValue += (1-isoLevel) * noiseValue;
    if(densityValue+noiseValue > 1)
    {
        densityValue = isoLevel;
    }
    else
    {
        densityValue += noiseValue;
    }*/
    return densityValue;
}

void SetPosition(int3 coord)
{
    samplePoints[index].x = coord.x * voxelSize + offset.x;
    samplePoints[index].y = coord.y * voxelSize + offset.y;
    samplePoints[index].z = coord.z * voxelSize + offset.z;
}

[numthreads(1,1,1)]
void CSMain (uint3 threadID : SV_DISPATCHTHREADID)
{
    if(threadID.x>numVertexX || threadID.y>numVertexY || threadID.z>numVertexZ)
    {
        return;
    }
    totalVertexLayer = numVertexX*numVertexZ;

    index = GetIDFromCoord(threadID);
    SetPosition(threadID);
    samplePoints[index].w = SetDensity(index);
}
