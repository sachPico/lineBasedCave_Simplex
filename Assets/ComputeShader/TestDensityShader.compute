#pragma kernel CSMain
#include "/Include/Inputs.compute"
#include "/Include/SimplexNoise.compute"

struct LineProperties
{
    int nodeA, nodeB;
    float3 xLocal, yLocal;
    float AC, BD, CE, DF, lineLength;
};

struct NodeProperties
{
    float3 position;
    float minRadius, maxRadius;
};

bool isWorldSpaceNoise;
int totalVertexLayer, totalVertex, index;
float1 smoothingFactor;
float1 noiseIntensity;
float3 offset;
float1 noiseScale;

StructuredBuffer<float3> noiseOffset;
RWStructuredBuffer<NodeProperties> nodeProps;
RWStructuredBuffer<LineProperties> lineProps;

bool IsInRadius(NodeProperties n, float1 r, float3 sp)
{
    float1 dist = length(sp - n.position);
    if(dist <= r) return true;
    else return false;
}

bool IsOutRadius(NodeProperties n, float1 r, float3 sp)
{
    float1 dist = length(sp - n.position);
    if(dist >= r) return true;
    else return false;
}

float1 Falloff(float1 dist, float1 minR, float1 maxR)
{
    float1 fV = (maxR-dist)/(maxR-minR);
    if(fV<isoLevel) return 0;
    else return clamp(fV,0.0001,isoLevel);
}

float1 EndToEndDensity(NodeProperties np, int spID)
{
    if(length(samplePoints[spID]-np.position) < np.maxRadius)
    {
        return Falloff(length(samplePoints[spID]-np.position), 0, np.maxRadius);
    }
    else
    {
        return 0;
    }
}

int GetClosestLineID(float4 sp)
{
    LineProperties lp;
    NodeProperties nA, nB;
    float1 interpolatedRadius, orthogonalProjection, sampleToLine, closestDist;//interpolateR, orthogonalProjection, lineLength, distToLine, closestDist;
    float3 nodeAToSample, nodeBToSample;
    int closestLineIndex=-1;

    closestDist = 2147483647;

    for(uint i=0; i<lineProps.Length; i++)
    {
        lp = lineProps[i];
        nA = nodeProps[lp.nodeA];
        nB = nodeProps[lp.nodeB];

        if(nodeProps[lp.nodeA].maxRadius < nodeProps[lp.nodeB].maxRadius)
        {
            nA=nodeProps[lp.nodeA];
            nB=nodeProps[lp.nodeB];
        }
        else
        {
            nA=nodeProps[lp.nodeB];
            nB=nodeProps[lp.nodeA];
        }

        nodeAToSample = sp.xyz - nA.position;
        nodeBToSample = sp.xyz - nB.position;
        orthogonalProjection = dot(nodeAToSample, normalize(nB.position-nA.position));
        sampleToLine = sqrt(pow(length(nodeAToSample),2)-pow(orthogonalProjection,2));
        interpolatedRadius = (orthogonalProjection+lp.AC)/(lp.lineLength+lp.AC-lp.BD)*(lp.DF-lp.CE)+lp.CE;

        //if(closestLineIndex==-1)
        //{
            if(sp.w!=-1 && sampleToLine <= interpolatedRadius && orthogonalProjection>=-nA.maxRadius && orthogonalProjection<=lp.lineLength+nB.maxRadius)
            {
                closestDist = sampleToLine;
                closestLineIndex=i;
            }
        //}

        /*if(orthogonalProjection>-lp.AC && orthogonalProjection<lp.lineLength-lp.BD && sampleToLine<closestDist && sampleToLine<interpolatedRadius)
        {
            closestDist = sampleToLine;
            closestLineIndex = i;
        }*/
        //else
        //{
            //if(orthogonalProjection>-nA.maxRadius || orthogonalProjection>lp.lineLength+nB.maxRadius)
            //{
            //    closestDist = sampleToLine;
            //    closestLineIndex = i;
            //}
        //}

        /*if(sampleToLine < closestDist)//&& sampleToLine <= interpolatedRadius && orthogonalProjection >= -lp.AC && orthogonalProjection <= lp.lineLength-lp.BD)
        {
            closestDist = sampleToLine;
            closestLineIndex=i;
        }*/
    }
    return closestLineIndex;
    
}

float1 SetDensity(int index)
{
    NodeProperties closestNodeA, closestNodeB;
    float1 lineLength, orthogonalProjectionToClosestLine, falloffValue, densityValue;
    float3 normalizedLine;
    
    int id = GetClosestLineID(samplePoints[index]);
    if(id==-1)
    {
        return 0;
    }
    /*if(id!=0)
    {
        return 0;
    }*/
    //return id;
    LineProperties closestLineProps = lineProps[id];
    if(nodeProps[lineProps[id].nodeA].maxRadius < nodeProps[lineProps[id].nodeB].maxRadius)
    {
        closestNodeA = nodeProps[closestLineProps.nodeA];
        closestNodeB = nodeProps[closestLineProps.nodeB];
    }
    else
    {
        closestNodeA = nodeProps[closestLineProps.nodeB];
        closestNodeB = nodeProps[closestLineProps.nodeA];
    }

    /*if((closestNodeA.position.x>numVertexX-1 * voxelSize || closestNodeA.position.y>numVertexY-1 * voxelSize || closestNodeA.position.z>numVertexZ-1 * voxelSize) || (closestNodeB.position.x>numVertexX-1 * voxelSize || closestNodeB.position.y>numVertexY-1 * voxelSize || closestNodeB.position.z>numVertexZ-1 * voxelSize))
    {
        return 0;
    }*/

    normalizedLine = normalize(closestNodeB.position-closestNodeA.position);
    orthogonalProjectionToClosestLine = dot(samplePoints[index].xyz-closestNodeA.position, normalizedLine);

    /*if(orthogonalProjectionToClosestLine<=-closestLineProps.AC)
    {
        densityValue = EndToEndDensity(closestNodeA, index);
        
    }
    else if(orthogonalProjectionToClosestLine>=closestLineProps.lineLength-closestLineProps.BD)
    {
        densityValue = EndToEndDensity(closestNodeB, index);
        
    }
    else//if(orthogonalProjectionToClosestLine>=-closestNodeA.maxRadius && orthogonalProjectionToClosestLine<=closestLineProps.lineLength+closestNodeA.maxRadius)
    {*/
        //return 0;
        float3 orthoProject = closestNodeA.position+(orthogonalProjectionToClosestLine * normalizedLine);
        float1 dist = sqrt(pow(length(samplePoints[index].xyz-closestNodeA.position),2) - pow(orthogonalProjectionToClosestLine,2));//length(orthoProject - samplePoints[index].xyz);

        float1 interpolatedMaxRadius, interpolatedMinRadius;
        interpolatedMaxRadius = closestLineProps.CE + ((orthogonalProjectionToClosestLine+closestLineProps.AC)/(closestLineProps.lineLength+closestLineProps.AC-closestLineProps.BD) * (closestLineProps.DF - closestLineProps.CE));
        
        if(dist <= interpolatedMaxRadius)// && orthogonalProjectionToClosestLine>=-closestLineProps.AC && orthogonalProjectionToClosestLine<=closestLineProps.lineLength-closestLineProps.BD)
        {
            falloffValue = Falloff(dist, 0, interpolatedMaxRadius);//float1 falloffValue = ;
            densityValue = 0;//isoLevel;//clamp(falloffValue + isoLevel,0,1);
        }
        else
        {
            return 0;
        }
        
    //}
    float3 noiseInput;
    float noiseValue=0;
    if(isWorldSpaceNoise)
    {
        noiseInput = samplePoints[index].xyz / noiseScale;
    }
    else
    {
        noiseInput.z = orthogonalProjectionToClosestLine / noiseScale;
        noiseInput.x = dot(samplePoints[index].xyz-closestNodeA.position, closestLineProps.xLocal) / noiseScale;
        noiseInput.y = dot(samplePoints[index].xyz-closestNodeA.position, closestLineProps.yLocal) / noiseScale;
    }
    for(int i=0; i<noiseOffset.Length; i++)
    {
        noiseValue += noise3D(noiseInput.x + noiseOffset[i].x, noiseInput.y + noiseOffset[i].y, noiseInput.z + noiseOffset[i].z);
    }
    noiseValue /= noiseOffset.Length*noiseIntensity;
    if(densityValue+noiseValue > 1)
    {
        densityValue = isoLevel + (noiseValue*isoLevel);
    }
    else
    {
        densityValue += noiseValue + isoLevel;
    }
    return densityValue;
}

void SetPosition(int3 coord)
{
    samplePoints[index].x = coord.x * voxelSize + offset.x;
    samplePoints[index].y = coord.y * voxelSize + offset.y;
    samplePoints[index].z = coord.z * voxelSize + offset.z;
}

[numthreads(1,1,1)]
void CSMain (uint3 threadID : SV_DISPATCHTHREADID)
{
    if(threadID.x>numVertexX || threadID.y>numVertexY || threadID.z>numVertexZ)// || threadID.x==0 || threadID.y==0 || threadID.z==0)
    {
        return;//samplePoints[index].w = 0;
    }
    totalVertexLayer = numVertexX*numVertexZ;  //Total Vertex dalam satu lapis
    //totalVertex= totalVertexLayer*numVertexY;

    index = GetIDFromCoord(threadID);
    SetPosition(threadID);
    samplePoints[index].w = SetDensity(index);
}
